
CCEffect %{
techniques: 
  - passes: 
      - vert: vs
        frag: fs
        blendState: 
          targets: 
            - blend: true
        rasterizerState: 
          cullMode: none
        properties: 
          texture: 
            value: white
          uSize: 
            value: 
              - 300.0
              - 300.0
          uIntensity: 
            value: 4.0
}%
        
CCProgram vs %{
    precision highp float;
    #include <cc-global>
    #include <cc-local>

    in vec3 a_position;
    #if USE_TEXTURE
        in vec2 a_uv0;
        out vec2 v_uv0;
    #endif  
    in vec4 a_color;
    out vec4 v_color;

    void main () {
        mat4 mvp;
        #if CC_USE_MODEL
            mvp = cc_matViewProj * cc_matWorld;
        #else
            mvp = cc_matViewProj;
        #endif

        #if USE_TEXTURE
            v_uv0 = a_uv0;
        #endif

        #if USE_TINT
            // clear warning for spine
        #endif

        v_color = a_color;
        gl_Position = mvp * vec4(a_position, 1);
    }
}%
        
CCProgram fs %{
    precision highp float;
    #include <cc-global>
    #if USE_TEXTURE
        in vec2 v_uv0;
        uniform sampler2D texture;
    #endif
    in vec4 v_color;
    uniform Constant {
		vec2 uSize;
		float uIntensity;
	};
	uniform sampler2D uTex;

    vec2 nearestHex(float s, vec2 st) 
	{
	    float h = 0.5 * s;
	    float r = 0.8660254 * s;
	    float b = s + 2.0 * h;
	    float a = 2.0 * r;
	    float m = h / r;
	    vec2 sect = st/vec2(2.0 * r, h + s);
	    vec2 sectPxl = mod(st, vec2(2.0 * r, h + s));
	    float aSection = mod(floor(sect.y), 2.0);
	    vec2 coord = floor(sect);
	    if(aSection > 0.0) {
	        if(sectPxl.y < (h - sectPxl.x * m)) {
	            coord -= 1.0;
	        }
	        else if(sectPxl.y < (-h + sectPxl.x * m)) {
	            coord.y -= 1.0;
	        }
	    }
	    else {
	       if(sectPxl.x > r) {
	           if(sectPxl.y < (2.0 * h - sectPxl.x * m)) {
	               coord.y -= 1.0;
	           }
	       }
	       else {
	           if(sectPxl.y < (sectPxl.x * m)) {
	               coord.y -= 1.0;
	           }
	           else{
	               coord.x -= 1.0;
	           }
	       }
	    }
	    float xoff = mod(coord.y, 2.0) * r;
	    return vec2(coord.x * 2.0 * r - xoff, coord.y * (h + s)) + vec2(r * 2.0, s);
	}
	float hexDist(vec2 a, vec2 b) 
	{
	    vec2 p = abs(b - a);
	    float s = 0.5;
	    float c = 0.8660254;
	    float diagDist = s * p.x + c * p.y;
	    return max(diagDist, p.x) / c;
	}
	vec4 HexagonPixel_main(sampler2D Tex, vec2 UV, vec2 Size, float Intensity) 
	{
	    vec2 uv = UV;
	    float s = Intensity * Size.x / 160.0;
	    vec2 nearest  = nearestHex(s, UV * Size);
	    vec4 texel  = texture2D(Tex, nearest / Size);
	    float dist    = hexDist(UV * Size, nearest);
	    float luminance = (texel.r + texel.g + texel.b) / 3.0;
	    float interiorSize = s;
	    float interior = 1.0 - smoothstep(interiorSize - 1.0, interiorSize, dist);
	    return vec4(texel.rgb * interior, texture2D(Tex, UV).a);
	}
	    
	void main () {
	    gl_FragColor = HexagonPixel_main(texture, v_uv0, uSize, uIntensity);
	} 
	
}%
        